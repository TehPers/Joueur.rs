<%
if not 'rs' in shared:
    import textwrap

    shared['rs'] = {}

    def rs_type(type_obj, impl=False):
        type_name = type_obj['name']

        prefix = ''
        if not impl:
            prefix = '&'

        if type_name == 'dictionary':
            return prefix + 'std::collections::HashMap<{}, {}>'.format(
                rs_type(type_obj['keyType']),
                rs_type(type_obj['valueType'])
            )
        elif type_name == 'list':
            child = rs_type(type_obj['valueType'], impl)
            if prefix:
                return prefix + '[{}]'.format(child)
            else:
                return 'Vec<{}>'.format(child)
        elif type_name == 'int':
            return prefix + 'i32'
        elif  type_name == 'float':
            return prefix + 'f64'
        elif type_name == 'boolean':
            return prefix + 'bool'
        elif type_name == 'string':
            if impl:
                return 'String'
            else:
                return '&str'
        elif type_obj['is_game_object']:
            if impl:
                return 'Option<{}Ref>'.format(type_name)

            game_obj = '& dyn ' + type_name
            if type_obj['nullable']:
                return 'Option<{}>'.format(game_obj)
            return game_obj
    shared['rs']['type'] = rs_type

    def rs_default(type_obj):
        type_name = type_obj['name']
        sdef = str(type_obj['default']) if 'default' in type_obj else ''

        if type_name == 'dictionary':
            return 'std::collections::HashMap::new()'
        elif type_name == 'list':
            return 'vec!()'
        elif type_name == 'int':
            return sdef or '0'
        elif  type_name == 'float':
            return sdef or '0'
        elif type_name == 'boolean':
            return sdef.lower() or 'false'
        elif type_name == 'string':
            return '"{}".to_string()'.format(sdef) if sdef else 'String::new()'
        elif type_obj['is_game_object']:
            return 'None'
    shared['rs']['default'] = rs_default

    def rs_imports(obj, obj_name, already_importing):
        importing = set(already_importing or [])
        def add(type_obj):
            type_name = type_obj['name']
            if type_name == 'dictionary' or type_name == 'list':
                add(type_obj['valueType'])
            elif type_obj['is_game_object']:
                importing.add(type_name)

        if 'attributes' in obj:
            for attr_name in obj['attribute_names']:
                add(obj['attributes'][attr_name]['type'])

        if obj_name in importing and obj_name not in already_importing:
            importing.remove(obj_name)

        importing = sorted(importing)
        if not importing:
            return ''
        return 'use crate::games::{}::{{\n{}\n}};'.format(underscore(game_name), '\n'.join(['    {},'.format(i) for i in importing]))
    shared['rs']['imports'] = rs_imports

    def rs_description(line):
        return (line
            .replace('true', '`true`')
            .replace('True', '`true`')
            .replace('false', '`false`')
            .replace('False', '`false`')
            .replace("'", '"')
            .replace('null', 'None')
            .replace('Null', '`None`')
        )
    shared['rs']['description'] = rs_description

    def rs_docstring(obj, indent_level=1):
        wrapper_prefix = ('    ' * indent_level) + '///'
        wrapper = textwrap.TextWrapper(
            width=(77 - len(wrapper_prefix)),
            replace_whitespace=False,
            expand_tabs=False,
        )
        docstring = '\n'.join(wrapper.wrap(rs_description(obj['description'])))

        if 'arguments' in obj and len(obj['arguments']) > 0:
            docstring += '\n\n# Arguments\n\n'
            for arg in obj['arguments']:
                docstring += '\n'.join(wrapper.wrap('* `{}` - {}'.format(arg['name'], rs_description(arg['description'])))) + '\n'
        if 'returns' in obj and obj['returns']:
            if not 'arguments' in obj or not len(obj['arguments']) > 0:
                docstring += '\n'
            docstring += '\n# Returns\n\n'
            docstring += '\n'.join(wrapper.wrap((rs_description(obj['returns']['description']))))

        return wrapper_prefix + ('\n' + wrapper_prefix).join([ '' if not line else (' ' + line) for line in  docstring.split('\n')])
    shared['rs']['docstring'] = rs_docstring

    def rs_function_top(func_name, func):
        docstring = rs_docstring(func) + '\n'

        fn = ['    fn ', underscore(func_name), '(']
        args = ["&self"]
        if func['arguments']:
            for i, arg in enumerate(func['arguments']):
                args.append(''.join([underscore(arg['name']), ': ', rs_type(arg['type'])]))
        returns = []
        if func['returns']:
            returns.extend(['-> ', rs_type(func['returns']['type'], False)])
        one_line_args = list(fn)
        one_line_args.append(', '.join(args))
        one_line_args.append(') ')
        one_line_args.extend(returns)

        as_one_line = ''.join(one_line_args)
        if len(as_one_line) < 79:
            return docstring + as_one_line
        # else too long, so wrap each arg on a separate line
        multi_lines = list(fn)
        multi_lines.extend(['\n', ',\n'.join(args)], '\n)')
        multi_lines.extend(returns)
        return docstring + ''.join(multi_lines)
    shared['rs']['function_top'] = rs_function_top

    def rs_deep_type_name(base_type):
        type_name = base_type['name']
        if type_name == 'list':
            return 'list_of_{}'.format(rs_deep_type_name(base_type['valueType']))
        if type_name == 'dictionary':
            return 'map_of_{}_to_{}'.format(rs_deep_type_name(base_type['keyType']), rs_deep_type_name(base_type['valueType']))
        if base_type['is_game_object']:
            return 'game_object_ref'
        # default case
        return underscore(type_name)
    shared['rs']['deep_type_name'] = rs_deep_type_name

    def rs_parents(obj_key, obj):
        objs = [(obj_key, obj)] + [ (n, game_objs[n]) for n in obj['parentClasses'] ]
        objs = [r for r in reversed(objs)]
        return objs
    shared['rs']['parents'] = rs_parents
%>